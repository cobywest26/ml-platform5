<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Platform - Machine Learning Workbench</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; 
            background: #f8f9fa;
            color: #212529;
        }
        
        .app-container {
            display: flex;
            min-height: 100vh;
        }
        
        .sidebar {
            width: 260px;
            background: linear-gradient(180deg, #6366f1 0%, #4f46e5 100%);
            color: white;
            padding: 24px 0;
            box-shadow: 4px 0 24px rgba(0,0,0,0.1);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-logo {
            padding: 0 24px 24px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 24px;
        }
        
        .sidebar-logo h1 {
            font-size: 24px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .logo-icon {
            width: 36px;
            height: 36px;
            background: rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        nav {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .nav-menu {
            list-style: none;
            flex: 1;
        }
        
        .nav-item {
            margin-bottom: 4px;
        }
        
        .nav-link {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 24px;
            color: rgba(255,255,255,0.8);
            text-decoration: none;
            transition: all 0.2s;
            cursor: pointer;
            font-size: 15px;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }
        
        .nav-link:hover {
            background: rgba(255,255,255,0.1);
            color: white;
        }
        
        .nav-link.active {
            background: rgba(255,255,255,0.15);
            color: white;
            font-weight: 500;
            border-right: 3px solid white;
        }
        
        .nav-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }
        
        .main-content {
            flex: 1;
            margin-left: 260px;
        }
        
        .content-header {
            background: white;
            border-bottom: 1px solid #e5e7eb;
            padding: 24px 40px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .content-header h2 {
            font-size: 28px;
            font-weight: 700;
            color: #1f2937;
        }
        
        .content-header p {
            color: #6b7280;
            margin-top: 4px;
            font-size: 14px;
        }
        
        .content-body {
            padding: 32px 40px;
            max-width: 1400px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 20px;
            margin-bottom: 32px;
        }
        
        .stat-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border: 1px solid #e5e7eb;
            transition: all 0.3s;
        }
        
        .stat-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
            transform: translateY(-2px);
        }
        
        .stat-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-bottom: 16px;
            color: white;
        }
        
        .stat-value {
            font-size: 32px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 4px;
        }
        
        .stat-label {
            font-size: 14px;
            color: #6b7280;
            font-weight: 500;
        }
        
        .card {
            background: white;
            border-radius: 12px;
            padding: 28px;
            margin-bottom: 24px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border: 1px solid #e5e7eb;
        }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }
        
        .card-title {
            font-size: 20px;
            font-weight: 600;
            color: #1f2937;
        }
        
        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 16px;
        }
        
        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }
        
        .btn-primary:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #e5e7eb;
        }
        
        .btn-secondary:hover {
            background: #e5e7eb;
        }
        
        .btn-success {
            background: #10b981;
            color: white;
        }
        
        .btn-success:hover {
            background: #059669;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #374151;
        }
        
        .input, .select {
            width: 100%;
            padding: 11px 14px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s;
            background: white;
        }
        
        .input:focus, .select:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
        
        .upload-zone {
            border: 2px dashed #d1d5db;
            border-radius: 12px;
            padding: 48px 32px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f9fafb;
        }
        
        .upload-zone:hover {
            border-color: #6366f1;
            background: #f5f3ff;
        }
        
        .upload-icon {
            font-size: 48px;
            margin-bottom: 16px;
            color: #6366f1;
        }
        
        .upload-text {
            font-size: 16px;
            font-weight: 500;
            color: #374151;
            margin-bottom: 8px;
        }
        
        .upload-subtext {
            font-size: 13px;
            color: #6b7280;
        }
        
        .alert {
            padding: 14px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
        }
        
        .alert-error {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #991b1b;
        }
        
        .alert-success {
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            color: #166534;
        }
        
        .alert-icon {
            font-size: 20px;
        }
        
        .table-container {
            overflow-x: auto;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 14px 16px;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
        }
        
        th {
            background: #f9fafb;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            color: #6b7280;
            letter-spacing: 0.5px;
        }
        
        tr:last-child td {
            border-bottom: none;
        }
        
        tr:hover {
            background: #f9fafb;
        }
        
        .rank-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-weight: 600;
            font-size: 14px;
        }
        
        .rank-1 {
            background: #fef3c7;
            color: #92400e;
        }
        
        .rank-2 {
            background: #e5e7eb;
            color: #374151;
        }
        
        .rank-3 {
            background: #fce7f3;
            color: #9f1239;
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }
        
        .checkbox-label:hover {
            background: #f9fafb;
            border-color: #6366f1;
        }
        
        .checkbox-label input {
            cursor: pointer;
        }
        
        .spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #6366f1;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .confusion-matrix {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            max-width: 400px;
            margin: 20px 0;
        }
        
        .cm-cell {
            padding: 28px;
            border-radius: 12px;
            text-align: center;
        }
        
        .cm-tp, .cm-tn {
            background: #d1fae5;
            color: #065f46;
            border: 2px solid #10b981;
        }
        
        .cm-fp, .cm-fn {
            background: #fee2e2;
            color: #991b1b;
            border: 2px solid #ef4444;
        }
        
        .cm-value {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .cm-label {
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .auth-container {
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .auth-card {
            background: white;
            padding: 48px;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 440px;
            width: 100%;
        }
        
        .auth-logo {
            width: 72px;
            height: 72px;
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            border-radius: 50%;
            margin: 0 auto 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 32px;
            font-weight: 700;
        }
        
        .auth-title {
            text-align: center;
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            color: #1f2937;
        }
        
        .auth-subtitle {
            text-align: center;
            color: #6b7280;
            margin-bottom: 32px;
            font-size: 14px;
        }
        
        .auth-toggle {
            text-align: center;
            margin-top: 24px;
            font-size: 14px;
            color: #6b7280;
        }
        
        .auth-toggle button {
            background: none;
            border: none;
            color: #6366f1;
            font-weight: 600;
            cursor: pointer;
            text-decoration: underline;
        }
        
        .data-preview {
            max-height: 300px;
            overflow: auto;
            margin-top: 16px;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .badge-success {
            background: #d1fae5;
            color: #065f46;
        }
        
        .badge-info {
            background: #dbeafe;
            color: #1e40af;
        }
        
        .empty-state {
            text-align: center;
            padding: 48px 24px;
            color: #6b7280;
        }
        
        .empty-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        .empty-title {
            font-size: 18px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }
        
        .empty-text {
            font-size: 14px;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 24px;
        }
        
        .comparison-card {
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
        }
        
        .comparison-card.best {
            border-color: #fbbf24;
            background: #fffbeb;
        }
        
        .comparison-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .comparison-model-name {
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .metric-row:last-child {
            border-bottom: none;
        }
        
        .metric-name {
            font-size: 13px;
            color: #6b7280;
            font-weight: 500;
        }
        
        .metric-value {
            font-size: 14px;
            color: #1f2937;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script>
        const { createElement: h, useState } = React;
        const { createRoot } = ReactDOM;
        let data = []; // Global dataset variable for uploads & training

        // Simple ML Models with better error handling
        class LinearRegression {
            fit(X, y) {
                const n = X[0].length;
                this.weights = new Array(n).fill(0);
                this.bias = 0;
                const lr = 0.01;
                
                for (let epoch = 0; epoch < 500; epoch++) {
                    let predictions = X.map(row => {
                        let pred = this.bias;
                        for (let i = 0; i < n; i++) {
                            pred += row[i] * this.weights[i];
                        }
                        return pred;
                    });
                    
                    let errors = predictions.map((p, i) => p - y[i]);
                    
                    for (let i = 0; i < n; i++) {
                        let gradient = 0;
                        for (let j = 0; j < X.length; j++) {
                            gradient += errors[j] * X[j][i];
                        }
                        this.weights[i] -= lr * gradient / X.length;
                    }
                    
                    let biasGradient = errors.reduce((a, b) => a + b, 0) / X.length;
                    this.bias -= lr * biasGradient;
                }
            }
            
            predict(X) {
                return X.map(row => {
                    let pred = this.bias;
                    for (let i = 0; i < row.length; i++) {
                        pred += row[i] * this.weights[i];
                    }
                    return pred;
                });
            }
        }

        class LogisticRegression {
            sigmoid(z) {
                return 1 / (1 + Math.exp(-z));
            }
            
            fit(X, y) {
                const n = X[0].length;
                this.weights = new Array(n).fill(0);
                this.bias = 0;
                const lr = 0.01;
                
                for (let epoch = 0; epoch < 500; epoch++) {
                    for (let i = 0; i < X.length; i++) {
                        let z = this.bias;
                        for (let j = 0; j < n; j++) {
                            z += X[i][j] * this.weights[j];
                        }
                        let pred = this.sigmoid(z);
                        let error = pred - y[i];
                        
                        for (let j = 0; j < n; j++) {
                            this.weights[j] -= lr * error * X[i][j];
                        }
                        this.bias -= lr * error;
                    }
                }
            }
            
            predict(X) {
                return X.map(row => {
                    let z = this.bias;
                    for (let i = 0; i < row.length; i++) {
                        z += row[i] * this.weights[i];
                    }
                    return this.sigmoid(z);
                });
            }
            
            predictClass(X) {
                return this.predict(X).map(p => p >= 0.5 ? 1 : 0);
            }
        }

        class DecisionTree {
            constructor(maxDepth = 5, minSamples = 2) {
                this.maxDepth = maxDepth;
                this.minSamples = minSamples;
            }
            
            gini(y) {
                if (y.length === 0) return 0;
                const counts = {};
                y.forEach(val => counts[val] = (counts[val] || 0) + 1);
                let impurity = 1;
                for (let key in counts) {
                    const prob = counts[key] / y.length;
                    impurity -= prob * prob;
                }
                return impurity;
            }
            
            split(X, y, feature, threshold) {
                const leftX = [], leftY = [], rightX = [], rightY = [];
                for (let i = 0; i < X.length; i++) {
                    if (X[i][feature] <= threshold) {
                        leftX.push(X[i]);
                        leftY.push(y[i]);
                    } else {
                        rightX.push(X[i]);
                        rightY.push(y[i]);
                    }
                }
                return { leftX, leftY, rightX, rightY };
            }
            
            findBestSplit(X, y) {
                let bestGain = 0;
                let bestFeature = 0;
                let bestThreshold = 0;
                const currentGini = this.gini(y);
                
                for (let feature = 0; feature < X[0].length; feature++) {
                    const values = [...new Set(X.map(row => row[feature]))].sort((a, b) => a - b);
                    
                    for (let i = 0; i < values.length - 1; i++) {
                        const threshold = (values[i] + values[i + 1]) / 2;
                        const { leftY, rightY } = this.split(X, y, feature, threshold);
                        
                        if (leftY.length === 0 || rightY.length === 0) continue;
                        
                        const leftGini = this.gini(leftY);
                        const rightGini = this.gini(rightY);
                        const weightedGini = (leftY.length / y.length) * leftGini + 
                                           (rightY.length / y.length) * rightGini;
                        const gain = currentGini - weightedGini;
                        
                        if (gain > bestGain) {
                            bestGain = gain;
                            bestFeature = feature;
                            bestThreshold = threshold;
                        }
                    }
                }
                
                return { feature: bestFeature, threshold: bestThreshold, gain: bestGain };
            }
            
            buildTree(X, y, depth) {
                const uniqueClasses = [...new Set(y)];
                
                if (uniqueClasses.length === 1 || depth >= this.maxDepth || y.length < this.minSamples) {
                    const counts = {};
                    y.forEach(val => counts[val] = (counts[val] || 0) + 1);
                    const majority = Object.keys(counts).reduce((a, b) => 
                        counts[a] > counts[b] ? a : b
                    );
                    return { leaf: true, value: parseFloat(majority) };
                }
                
                const { feature, threshold, gain } = this.findBestSplit(X, y);
                
                if (gain === 0) {
                    const counts = {};
                    y.forEach(val => counts[val] = (counts[val] || 0) + 1);
                    const majority = Object.keys(counts).reduce((a, b) => 
                        counts[a] > counts[b] ? a : b
                    );
                    return { leaf: true, value: parseFloat(majority) };
                }
                
                const { leftX, leftY, rightX, rightY } = this.split(X, y, feature, threshold);
                
                return {
                    leaf: false,
                    feature,
                    threshold,
                    left: this.buildTree(leftX, leftY, depth + 1),
                    right: this.buildTree(rightX, rightY, depth + 1)
                };
            }
            
            fit(X, y) {
                this.tree = this.buildTree(X, y, 0);
            }
            
            predictOne(x, node = this.tree) {
                if (node.leaf) return node.value;
                if (x[node.feature] <= node.threshold) {
                    return this.predictOne(x, node.left);
                } else {
                    return this.predictOne(x, node.right);
                }
            }
            
            predict(X) {
                return X.map(x => this.predictOne(x));
            }
        }

        class Bagging {
            constructor(nEstimators = 10) {
                this.nEstimators = nEstimators;
                this.trees = [];
            }
            
            fit(X, y) {
                for (let i = 0; i < this.nEstimators; i++) {
                    const indices = [];
                    for (let j = 0; j < X.length; j++) {
                        indices.push(Math.floor(Math.random() * X.length));
                    }
                    
                    const bootstrapX = indices.map(idx => X[idx]);
                    const bootstrapY = indices.map(idx => y[idx]);
                    
                    const tree = new DecisionTree();
                    tree.fit(bootstrapX, bootstrapY);
                    this.trees.push(tree);
                }
            }
            
            predict(X) {
                const predictions = this.trees.map(tree => tree.predict(X));
                
                return X.map((_, i) => {
                    const votes = predictions.map(pred => pred[i]);
                    const counts = {};
                    votes.forEach(v => counts[v] = (counts[v] || 0) + 1);
                    return parseFloat(Object.keys(counts).reduce((a, b) => 
                        counts[a] > counts[b] ? a : b
                    ));
                });
            }
        }

        class RandomForest {
            constructor(nEstimators = 10) {
                this.nEstimators = nEstimators;
                this.trees = [];
            }
            
            fit(X, y) {
                for (let i = 0; i < this.nEstimators; i++) {
                    const indices = [];
                    for (let j = 0; j < X.length; j++) {
                        indices.push(Math.floor(Math.random() * X.length));
                    }
                    
                    const bootstrapX = indices.map(idx => X[idx]);
                    const bootstrapY = indices.map(idx => y[idx]);
                    
                    const tree = new DecisionTree();
                    tree.fit(bootstrapX, bootstrapY);
                    this.trees.push(tree);
                }
            }
            
            predict(X) {
                const predictions = this.trees.map(tree => tree.predict(X));
                
                return X.map((_, i) => {
                    const votes = predictions.map(pred => pred[i]);
                    const counts = {};
                    votes.forEach(v => counts[v] = (counts[v] || 0) + 1);
                    return parseFloat(Object.keys(counts).reduce((a, b) => 
                        counts[a] > counts[b] ? a : b
                    ));
                });
            }
        }

        class DecisionStump {
            fit(X, y /*, weights */) {
                // pick first feature, split at its median
                const f = 0;
                const values = X.map(row => row[f]).sort((a, b) => a - b);
                const thr = values[Math.floor(values.length / 2)];
                this.f = f;
                this.thr = thr;
            }
            predict(X) {
                return X.map(row => (row[this.f] <= this.thr ? 1 : -1));
            }
        }

        // Simplified AdaBoost
        // ðŸ”¹ Fixed AdaBoost â€” handles 0/1 and Â±1 labels correctly
// ðŸ”¹ Robust AdaBoost implementation
class AdaBoost {
  constructor(baseLearner, nEstimators = 10) {
    this.baseLearner = baseLearner;
    this.nEstimators = nEstimators;
    this.models = [];
    this.alphas = [];
  }

  fit(X, y) {
    const n = X.length;
    if (n === 0) return;

    // âœ… Normalize labels to Â±1
    const yNorm = y.map(v => (v <= 0 ? -1 : 1));
    let weights = Array(n).fill(1 / n);

    for (let t = 0; t < this.nEstimators; t++) {
      const learner = new this.baseLearner();
      learner.fit(X, yNorm, weights);
      const preds = learner.predict(X);

      // ðŸ§® Weighted error
      const error = preds.reduce(
        (sum, p, i) => sum + (p !== yNorm[i] ? weights[i] : 0),
        0
      );

      // ðŸš« Skip degenerate stump
      if (error === 0 || isNaN(error) || error >= 0.5) continue;

      const alpha = 0.5 * Math.log((1 - error) / (error + 1e-10));
      this.models.push(learner);
      this.alphas.push(alpha);

      // ðŸ” Update weights
      weights = weights.map((w, i) => w * Math.exp(-alpha * yNorm[i] * preds[i]));
      const norm = weights.reduce((a, b) => a + b, 0);
      weights = weights.map(w => w / norm);
    }

    // ðŸ”¹ Ensure at least one model exists
    if (this.models.length === 0) {
      console.warn("AdaBoost trained no valid weak learners â€” adding fallback.");
      this.models.push(new this.baseLearner());
      this.alphas.push(0);
    }
  }

  predict(X) {
    if (this.models.length === 0) return Array(X.length).fill(0);
    const agg = Array(X.length).fill(0);

    for (let t = 0; t < this.models.length; t++) {
      const preds = this.models[t].predict(X);
      for (let i = 0; i < preds.length; i++) {
        agg[i] += this.alphas[t] * preds[i];
      }
    }

    const preds = agg.map(a => (a >= 0 ? 1 : 0));
    const hasValid = preds.some(p => p === 1) && preds.some(p => p === 0);
    return hasValid ? preds : Array(X.length).fill(0);
  }
}


        // Simplified SVM
        class SVM {
            fit(X, y) {
                this.X = X;
                this.y = y;
                this.w = new Array(X[0].length).fill(0);
                this.b = 0;
                const lr = 0.001;
                const lambda = 0.01;
                
                for (let epoch = 0; epoch < 1000; epoch++) {
                    for (let i = 0; i < X.length; i++) {
                        let margin = y[i] * (this.w.reduce((sum, w, j) => sum + w * X[i][j], 0) + this.b);
                        
                        if (margin < 1) {
                            for (let j = 0; j < this.w.length; j++) {
                                this.w[j] -= lr * (2 * lambda * this.w[j] - X[i][j] * y[i]);
                            }
                            this.b -= lr * (-y[i]);
                        } else {
                            for (let j = 0; j < this.w.length; j++) {
                                this.w[j] -= lr * (2 * lambda * this.w[j]);
                            }
                        }
                    }
                }
            }
            
            predict(X) {
                return X.map(x => {
                    const val = this.w.reduce((sum, w, i) => sum + w * x[i], 0) + this.b;
                    return val >= 0 ? 1 : 0;
                });
            }
        }

        // Simple Neural Network
        class NeuralNetwork {
            constructor() {
                this.hiddenSize = 10;
                this.lr = 0.01;
            }
            
            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }
            
            fit(X, y) {
                const inputSize = X[0].length;
                
                this.w1 = Array.from({ length: inputSize }, () => 
                    Array.from({ length: this.hiddenSize }, () => Math.random() * 0.1 - 0.05)
                );
                this.w2 = Array.from({ length: this.hiddenSize }, () => Math.random() * 0.1 - 0.05);
                this.b1 = new Array(this.hiddenSize).fill(0);
                this.b2 = 0;
                
                for (let epoch = 0; epoch < 1000; epoch++) {
                    for (let i = 0; i < X.length; i++) {
                        const hidden = new Array(this.hiddenSize);
                        for (let j = 0; j < this.hiddenSize; j++) {
                            hidden[j] = this.b1[j];
                            for (let k = 0; k < inputSize; k++) {
                                hidden[j] += X[i][k] * this.w1[k][j];
                            }
                            hidden[j] = Math.max(0, hidden[j]);
                        }
                        
                        let output = this.b2;
                        for (let j = 0; j < this.hiddenSize; j++) {
                            output += hidden[j] * this.w2[j];
                        }
                        output = this.sigmoid(output);
                        
                        const error = output - y[i];
                        
                        for (let j = 0; j < this.hiddenSize; j++) {
                            this.w2[j] -= this.lr * error * hidden[j];
                            
                            if (hidden[j] > 0) {
                                for (let k = 0; k < inputSize; k++) {
                                    this.w1[k][j] -= this.lr * error * this.w2[j] * X[i][k];
                                }
                            }
                        }
                        this.b2 -= this.lr * error;
                    }
                }
            }
            
            predict(X) {
                return X.map(x => {
                    const hidden = new Array(this.hiddenSize);
                    for (let j = 0; j < this.hiddenSize; j++) {
                        hidden[j] = this.b1[j];
                        for (let k = 0; k < x.length; k++) {
                            hidden[j] += x[k] * this.w1[k][j];
                        }
                        hidden[j] = Math.max(0, hidden[j]);
                    }
                    
                    let output = this.b2;
                    for (let j = 0; j < this.hiddenSize; j++) {
                        output += hidden[j] * this.w2[j];
                    }
                    return this.sigmoid(output);
                });
            }
            
            predictClass(X) {
                return this.predict(X).map(p => p >= 0.5 ? 1 : 0);
            }
        }

        // ROC Curve visualization
        function ROCCurve({ points = [], auc = 0 }) {
            const width = 600;
            const height = 400;

            const canvasRef = React.useRef(null);

            React.useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !Array.isArray(points) || points.length === 0) return;

                const ctx = canvas.getContext("2d");
                ctx.clearRect(0, 0, width, height);

                // ðŸŽ¨ Background grid
                ctx.strokeStyle = "#eee";
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                const x = (i / 10) * width;
                const y = (i / 10) * height;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
                }

                // ðŸ“Š ROC curve
                ctx.beginPath();
                ctx.moveTo(0, height);
                ctx.strokeStyle = "#7e3ff2";
                ctx.lineWidth = 2;
                points.forEach(({fpr, tpr}) => {
                const x = fpr * width;
                const y = height - tpr * height;
                ctx.lineTo(x, y);
                });
                ctx.stroke();

                // ðŸ”¹ Diagonal baseline
                ctx.beginPath();
                ctx.moveTo(0, height);
                ctx.lineTo(width, 0);
                ctx.strokeStyle = "#999";
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);

                // ðŸ·ï¸ AUC label
                ctx.fillStyle = "#333";
                ctx.font = "16px sans-serif";
                ctx.fillText(`AUC = ${auc.toFixed(3)}`, 10, 20);
            }, [points, auc]);

            return React.createElement("canvas", {
                ref: canvasRef,
                width,
                height,
                style: { border: "1px solid #ddd", marginTop: "10px", borderRadius: "8px" },
            });
}


        // Main App
        function MLPlatform() {
            const [isAuth, setIsAuth] = useState(false);
            const [isLogin, setIsLogin] = useState(true);
            const [username, setUsername] = useState('');
            const [password, setPassword] = useState('');
            const [email, setEmail] = useState('');
            const [users, setUsers] = useState([{ username: 'demo', password: 'demo123' }]);
            const [currentView, setCurrentView] = useState('dashboard');
            const [dataset, setDataset] = useState(null);
            const [features, setFeatures] = useState([]);
            const [target, setTarget] = useState('');
            const [taskType, setTaskType] = useState('classification');
            const [models, setModels] = useState([]);
            const [results, setResults] = useState([]);
            const [training, setTraining] = useState(false);
            const [error, setError] = useState('');
            const [success, setSuccess] = useState('');

            const hasData = Array.isArray(dataset) && dataset.length > 0;

            const handleAuth = () => {
                setError('');
                setSuccess('');
                if (isLogin) {
                    const user = users.find(u => u.username === username && u.password === password);
                    if (user) {
                        setIsAuth(true);
                        setSuccess('Login successful!');
                    } else {
                        setError('Invalid credentials');
                    }
                } else {
                    if (users.find(u => u.username === username)) {
                        setError('Username already exists');
                    } else {
                        setUsers([...users, { username, password, email }]);
                        setSuccess('Registration successful! Please login.');
                        setIsLogin(true);
                    }
                }
            };

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                data = [];
                setDataset(null);
                setFeatures([]);
                setTarget("");
                setSuccess("");
                setError("");

                if (file.name.endsWith('.csv') || file.name.endsWith('.txt')) {
                    Papa.parse(file, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: (result) => {
                            if (result.data && result.data.length > 0) {
                                setDataset(result.data);
                                setSuccess(`File uploaded! ${result.data.length} rows loaded.`);
                                data = result.data; // Store dataset globally for training
                            } else {
                                setError('No data found in file');
                            }
                        },
                        error: (error) => {
                            setError('Failed to parse file: ' + error.message);
                        }
                    });
                } else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const fileData = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(fileData, { type: 'array' });
                            const sheet = workbook.Sheets[workbook.SheetNames[0]];
                            const json = XLSX.utils.sheet_to_json(sheet);
                            if (json && json.length > 0) {
                                setDataset(json);
                                setSuccess(`File uploaded! ${json.length} rows loaded.`);
                                data = json; // Store Excel dataset globally for training
                            } else {
                                setError('No data found in Excel file');
                            }
                        } catch (err) {
                            setError('Failed to read Excel file');
                            console.error(err);
                        }
                    };
                    reader.onerror = () => {
                        setError('Failed to read file');
                    };
                    reader.readAsArrayBuffer(file);
                }

                const numericKeys = Object.keys(result.data[0] || {}).filter(k =>
                    result.data.some(row => !isNaN(parseFloat(row[k])))
                    );
                    setDataset(result.data.map(r =>
                    Object.fromEntries(Object.entries(r).filter(([k]) => numericKeys.includes(k)))
                    ));
            };

            const handleTrain = () => {
                if (!dataset || features.length === 0 || !target) {
                    setError('Please upload data and select features and target');
                    return;
                }

                setTraining(true);
                setError('');
                setSuccess('');
                
                setTimeout(() => {
                    try {
                        data = dataset || [];
                        console.log('Starting training...');
                        
                        // Filter and validate data
                        const validData = dataset.filter(row => {
                            const hasAllFeatures = features.every(f => {
                                const val = row[f];
                                return val != null && val !== '' && !isNaN(parseFloat(val));
                            });
                            const hasTarget = row[target] != null && row[target] !== '' && !isNaN(parseFloat(row[target]));
                            return hasAllFeatures && hasTarget;
                        });
                        
                        console.log("Starting training...");

                        // Ensure dataset is loaded globally
                        if (!data || data.length === 0) {
                        alert("No dataset loaded. Please upload a file first.");
                        return;
                        }

                        // Identify target and feature keys
                        const targetKey = target;
                        const featureKeys = features;

                        // Filter valid rows (non-empty and numeric for features)
                        const valid = data.filter(row => {
                        const hasAllFeatures = featureKeys.every(f => {
                            const val = row[f];
                            return val !== "" && val != null && !isNaN(parseFloat(val));
                        });
                        const hasTarget = row[targetKey] !== "" && row[targetKey] != null;
                        return hasAllFeatures && hasTarget;
                        });

                        if (valid.length < 10) {
                        alert(`Not enough valid data. Found only ${valid.length} complete rows. Need at least 10.`);
                        setTraining(false);
                        return;
                        }

                        console.log(`Valid rows: ${valid.length} out of ${data.length}`);

                        // --- Split into train/test sets (70/30) ---
                        const splitIndex = Math.floor(valid.length * 0.7);
                        const shuffled = [...valid].sort(() => Math.random() - 0.5);

                        const Xtrain = shuffled.slice(0, splitIndex).map(r => features.map(f => parseFloat(r[f])));
                        const ytrain = shuffled.slice(0, splitIndex).map(r => parseFloat(r[target]));

                        const Xtest = shuffled.slice(splitIndex).map(r => features.map(f => parseFloat(r[f])));
                        const ytest = shuffled.slice(splitIndex).map(r => parseFloat(r[target]));

                        console.log(`Split: ${Xtrain.length} train, ${Xtest.length} test`);


                        
                        const newResults = [];
                        
                        for (let modelConfig of models) {
                            try {
                                console.log('Training:', modelConfig.name);
                                const start = Date.now();
                                
                                let model;
                                switch(modelConfig.type) {
                                    case 'linear': model = new LinearRegression(); break;
                                    case 'logistic': model = new LogisticRegression(); break;
                                    case 'tree': model = new DecisionTree(); break;
                                    case 'bagging': model = new Bagging(); break;
                                    case 'forest': model = new RandomForest(); break;
                                    case 'adaboost': model = new AdaBoost(DecisionStump); break;
                                    case 'svm': model = new SVM(); break;
                                    case 'nn': model = new NeuralNetwork(); break;
                                    default: continue;
                                }
                                
                                model.fit(Xtrain, ytrain);
                                
                                let predictions;
                                if (modelConfig.type === 'linear') {
                                    predictions = model.predict(Xtest);
                                } else if (modelConfig.type === 'logistic' || modelConfig.type === 'nn') {
                                    predictions = model.predictClass(Xtest);
                                } else {
                                    predictions = model.predict(Xtest);
                                }
                                
                                if (!predictions || predictions.length !== ytest.length) {
                                    console.warn('Skipping ${modelConfig.name}: predictions mismatch');
                                    continue;
                                }
                                const time = Date.now() - start;
                                
                                let metrics = {};
                                
                                if (taskType === 'classification') {
                                    let tp = 0, tn = 0, fp = 0, fn = 0;
                                    
                                    for (let i = 0; i < predictions.length; i++) {
                                        const pred = Math.round(predictions[i]);
                                        const actual = Math.round(ytest[i]);
                                        
                                        if (pred === 1 && actual === 1) tp++;
                                        else if (pred === 0 && actual === 0) tn++;
                                        else if (pred === 1 && actual === 0) fp++;
                                        else if (pred === 0 && actual === 1) fn++;
                                    }
                                    
                                    const accuracy = (tp + tn) / predictions.length;
                                    const precision = tp + fp > 0 ? tp / (tp + fp) : 0;
                                    const recall = tp + fn > 0 ? tp / (tp + fn) : 0;
                                    const f1 = precision + recall > 0 ? 2 * precision * recall / (precision + recall) : 0;
                                    
                                    metrics = {
                                        accuracy,
                                        precision,
                                        recall,
                                        f1,
                                        confusionMatrix: { tp, tn, fp, fn }
                                    };
                                    
                                    // ROC curve for probabilistic models
                                    if (modelConfig.type === 'logistic' || modelConfig.type === 'nn') {
                                        try {
                                            const probs = model.predict(Xtest);
                                            const sorted = probs.map((p, i) => ({ 
                                                p, 
                                                y: Math.round(ytest[i]) 
                                            })).sort((a, b) => b.p - a.p);
                                            
                                            const rocCurve = [{ fpr: 0, tpr: 0 }];
                                            let tpCount = 0, fpCount = 0;
                                            const totalPos = ytest.filter(y => Math.round(y) === 1).length;
                                            const totalNeg = ytest.filter(y => Math.round(y) === 0).length;
                                            
                                            for (let point of sorted) {
                                                if (point.y === 1) tpCount++;
                                                else fpCount++;
                                                
                                                rocCurve.push({
                                                    fpr: totalNeg > 0 ? fpCount / totalNeg : 0,
                                                    tpr: totalPos > 0 ? tpCount / totalPos : 0
                                                });
                                            }
                                            
                                            rocCurve.push({ fpr: 1, tpr: 1 });
                                            
                                            let auc = 0;
                                            for (let i = 1; i < rocCurve.length; i++) {
                                                const width = rocCurve[i].fpr - rocCurve[i-1].fpr;
                                                const height = (rocCurve[i].tpr + rocCurve[i-1].tpr) / 2;
                                                auc += width * height;
                                            }
                                            
                                            metrics.rocCurve = rocCurve;
                                            metrics.rocAuc = auc;
                                        } catch (rocError) {
                                            console.error('ROC error:', rocError);
                                        }
                                    }
                                } else {
                                    // Regression metrics
                                    let mse = 0, mae = 0;
                                    for (let i = 0; i < predictions.length; i++) {
                                        const error = predictions[i] - ytest[i];
                                        mse += error * error;
                                        mae += Math.abs(error);
                                    }
                                    mse /= predictions.length;
                                    mae /= predictions.length;
                                    const rmse = Math.sqrt(mse);
                                    
                                    const yMean = ytest.reduce((a, b) => a + b, 0) / ytest.length;
                                    let ssTot = 0, ssRes = 0;
                                    for (let i = 0; i < ytest.length; i++) {
                                        ssTot += (ytest[i] - yMean) ** 2;
                                        ssRes += (ytest[i] - predictions[i]) ** 2;
                                    }
                                    const r2 = ssTot > 0 ? 1 - (ssRes / ssTot) : 0;
                                    
                                    metrics = { mse, mae, rmse, r2 };
                                }
                                
                                newResults.push({
                                    id: Math.random(),
                                    name: modelConfig.name,
                                    type: modelConfig.type,
                                    metrics,
                                    time
                                });
                                
                                console.log('Completed:', modelConfig.name, metrics);
                                
                            } catch (modelError) {
                                console.error('Error training', modelConfig.name, ':', modelError);
                            }
                        }
                        
                        if (newResults.length > 0) {
                            setResults(newResults);
                            setSuccess(`Training complete! ${newResults.length} models trained.`);
                            setCurrentView('results');
                        } else {
                            setError('All models failed to train. Check console for details.');
                        }
                        
                    } catch (err) {
                        console.error('Training error:', err);
                        setError('Training failed: ' + err.message);
                    } finally {
                        setTraining(false);
                    }
                }, 100);
            };

            if (!isAuth) {
                return h('div', { className: 'auth-container' },
                    h('div', { className: 'auth-card' },
                        h('div', { className: 'auth-logo' }, 'ðŸ¤–'),
                        h('h1', { className: 'auth-title' }, isLogin ? 'Welcome Back' : 'Create Account'),
                        h('p', { className: 'auth-subtitle' }, 
                            isLogin ? 'Sign in to your ML Platform account' : 'Start your machine learning journey'),
                        
                        error && h('div', { className: 'alert alert-error' },
                            h('span', { className: 'alert-icon' }, 'âš ï¸'),
                            error
                        ),
                        success && h('div', { className: 'alert alert-success' },
                            h('span', { className: 'alert-icon' }, 'âœ“'),
                            success
                        ),
                        
                        h('div', { className: 'form-group' },
                            h('label', { className: 'label' }, 'Username'),
                            h('input', {
                                className: 'input',
                                value: username,
                                onChange: e => setUsername(e.target.value),
                                placeholder: 'Enter username'
                            })
                        ),
                        
                        !isLogin && h('div', { className: 'form-group' },
                            h('label', { className: 'label' }, 'Email'),
                            h('input', {
                                className: 'input',
                                type: 'email',
                                value: email,
                                onChange: e => setEmail(e.target.value),
                                placeholder: 'Enter email'
                            })
                        ),
                        
                        h('div', { className: 'form-group' },
                            h('label', { className: 'label' }, 'Password'),
                            h('input', {
                                className: 'input',
                                type: 'password',
                                value: password,
                                onChange: e => setPassword(e.target.value),
                                placeholder: 'Enter password',
                                onKeyPress: e => e.key === 'Enter' && handleAuth()
                            })
                        ),
                        
                        h('button', {
                            className: 'btn btn-primary',
                            onClick: handleAuth,
                            style: { width: '100%', marginTop: '8px', justifyContent: 'center' }
                        }, isLogin ? 'Sign In' : 'Create Account'),
                        
                        h('div', { className: 'auth-toggle' },
                            isLogin ? "Don't have an account? " : 'Already have an account? ',
                            h('button', {
                                onClick: () => {
                                    setIsLogin(!isLogin);
                                    setError('');
                                    setSuccess('');
                                }
                            }, isLogin ? 'Sign Up' : 'Sign In')
                        )
                    )
                );
            }

            const stats = [
                { icon: 'ðŸ“Š', label: 'Datasets', value: hasData ? '1' : '0' },
                { icon: 'ðŸ¤–', label: 'Models', value: models.length },
                { icon: 'ðŸ§ª', label: 'Experiments', value: results.length },
                { icon: 'âœ“', label: 'Completed', value: results.length }
            ];

            return h('div', { className: 'app-container' },
                h('aside', { className: 'sidebar' },
                    h('div', { className: 'sidebar-logo' },
                        h('h1', null,
                            h('div', { className: 'logo-icon' }, 'ðŸ¤–'),
                            'ML Platform'
                        )
                    ),
                    h('nav', null,
                        h('ul', { className: 'nav-menu' },
                            ['dashboard', 'data', 'models', 'train', 'results'].map(view =>
                                h('li', { key: view, className: 'nav-item' },
                                    h('button', {
                                        className: `nav-link ${currentView === view ? 'active' : ''}`,
                                        onClick: () => setCurrentView(view)
                                    },
                                        h('span', { className: 'nav-icon' }, 
                                            view === 'dashboard' ? 'ðŸ“Š' :
                                            view === 'data' ? 'ðŸ“' :
                                            view === 'models' ? 'ðŸ¤–' :
                                            view === 'train' ? 'âš¡' : 'ðŸ“ˆ'
                                        ),
                                        view.charAt(0).toUpperCase() + view.slice(1)
                                    )
                                )
                            )
                        )
                    ),
                    h('div', { style: { padding: '24px', marginTop: 'auto', borderTop: '1px solid rgba(255,255,255,0.1)' } },
                        h('div', { style: { marginBottom: '12px', color: 'rgba(255,255,255,0.8)', fontSize: '14px' } },
                            'ðŸ‘¤ ' + username
                        ),
                        h('button', {
                            className: 'btn btn-secondary',
                            onClick: () => {
                                setIsAuth(false);
                                setUsername('');
                                setPassword('');
                                setDataset(null);
                                setResults([]);
                                setModels([]);
                                setFeatures([]);
                                setTarget('');
                                setCurrentView('dashboard');
                            },
                            style: { 
                                width: '100%', 
                                background: 'rgba(255,255,255,0.1)',
                                color: 'white',
                                border: '1px solid rgba(255,255,255,0.2)',
                                justifyContent: 'center'
                            }
                        }, 'ðŸšª Logout')
                    )
                ),
                
                h('main', { className: 'main-content' },
                    h('div', { className: 'content-header' },
                        h('h2', null, 
                            currentView === 'dashboard' ? 'Dashboard' :
                            currentView === 'data' ? 'Dataset Management' :
                            currentView === 'models' ? 'Model Selection' :
                            currentView === 'train' ? 'Train Models' :
                            'Training Results'
                        ),
                        h('p', null,
                            currentView === 'dashboard' ? 'Overview of your ML experiments' :
                            currentView === 'data' ? 'Upload and preview your datasets (.txt, .csv, Excel)' :
                            currentView === 'models' ? 'Select ML models to train and compare' :
                            currentView === 'train' ? 'Configure and start training' :
                            'Compare model performance with detailed metrics'
                        )
                    ),
                    
                    h('div', { className: 'content-body' },
                        error && h('div', { className: 'alert alert-error', onClick: () => setError('') },
                            h('span', { className: 'alert-icon' }, 'âš ï¸'),
                            error
                        ),
                        success && h('div', { className: 'alert alert-success', onClick: () => setSuccess('') },
                            h('span', { className: 'alert-icon' }, 'âœ“'),
                            success
                        ),
                        
                        currentView === 'dashboard' && h('div', null,
                            h('div', { className: 'stats-grid' },
                                stats.map(stat =>
                                    h('div', { key: stat.label, className: 'stat-card' },
                                        h('div', { className: 'stat-icon' }, stat.icon),
                                        h('div', { className: 'stat-value' }, stat.value),
                                        h('div', { className: 'stat-label' }, stat.label)
                                    )
                                )
                            ),
                            
                            h('div', { className: 'card' },
                                h('h3', { className: 'card-title' }, 'Quick Start'),
                                h('p', { style: { color: '#6b7280', marginBottom: '20px' } }, 
                                    'Upload a dataset and train models to get started.'),
                                h('div', { style: { display: 'flex', gap: '12px' } },
                                    h('button', {
                                        className: 'btn btn-primary',
                                        onClick: () => setCurrentView('data')
                                    }, 'ðŸ“ Upload Dataset'),
                                    h('button', {
                                        className: 'btn btn-secondary',
                                        onClick: () => setCurrentView('models'),
                                        disabled: !dataset
                                    }, 'ðŸ¤– Select Models')
                                )
                            )
                        ),
                        
                        currentView === 'data' && h('div', { className: 'card' },
                            h('div', { className: 'card-header' },
                                h('h3', { className: 'card-title' }, 'Upload Dataset'),
                                dataset && h('span', { className: 'badge badge-success' }, 
                                    `${dataset.length} rows`)
                            ),
                            
                            h('div', { className: 'upload-zone', onClick: () => document.getElementById('file').click() },
                                h('div', { className: 'upload-icon' }, 'ðŸ“'),
                                h('div', { className: 'upload-text' }, 
                                    dataset ? 'Dataset Loaded - Click to upload another' : 'Click to upload dataset'),
                                h('div', { className: 'upload-subtext' }, 
                                    'Supports TXT, CSV and Excel files'),
                                h('input', {
                                    id: 'file',
                                    type: 'file',
                                    accept: '.txt,.csv,.xlsx,.xls',
                                    style: { display: 'none' },
                                    onChange: handleFileUpload
                                })
                            ),
                            
                            hasData && h('div', { style: { marginTop: '24px' } },
                                h('h4', { className: 'section-title' }, 'Preview (first 10 rows)'),
                                h('div', { className: 'data-preview' },
                                    h('div', { className: 'table-container' },
                                        h('table', null,
                                            h('thead', null,
                                                h('tr', null,
                                                    Object.keys(dataset[0]).map(k =>
                                                        h('th', { key: k }, k)
                                                    )
                                                )
                                            ),
                                            h('tbody', null,
                                                dataset.slice(0, 10).map((row, i) =>
                                                    h('tr', { key: i },
                                                        Object.values(row).map((v, j) =>
                                                            h('td', { key: j }, String(v))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        ),
                        
                        currentView === 'models' && h('div', null,
                            h('div', { className: 'card' },
                                h('h3', { className: 'card-title', style: { marginBottom: '20px' } }, 
                                    'Configure Features'),
                                
                                h('div', { className: 'form-group' },
                                    h('label', { className: 'label' }, 'Task Type'),
                                    h('select', {
                                        className: 'select',
                                        value: taskType,
                                        onChange: e => setTaskType(e.target.value)
                                    },
                                        h('option', { value: 'classification' }, 'Classification'),
                                        h('option', { value: 'regression' }, 'Regression')
                                    )
                                ),
                                
                                dataset && h('div', { className: 'form-group' },
                                    h('label', { className: 'label' }, 'Target Variable'),
                                    h('select', {
                                        className: 'select',
                                        value: target,
                                        onChange: e => setTarget(e.target.value)
                                    },
                                        h('option', { value: '' }, 'Select target...'),
                                        Object.keys(dataset[0]).map(k =>
                                            h('option', { key: k, value: k }, k)
                                        )
                                    )
                                ),
                                
                                dataset && target && h('div', { className: 'form-group' },
                                    h('label', { className: 'label' }, 'Feature Variables'),
                                    h('div', { className: 'checkbox-group' },
                                        Object.keys(dataset[0]).filter(k => k !== target).map(col =>
                                            h('label', { key: col, className: 'checkbox-label' },
                                                h('input', {
                                                    type: 'checkbox',
                                                    checked: features.includes(col),
                                                    onChange: e => {
                                                        if (e.target.checked) {
                                                            setFeatures([...features, col]);
                                                        } else {
                                                            setFeatures(features.filter(f => f !== col));
                                                        }
                                                    }
                                                }),
                                                col
                                            )
                                        )
                                    )
                                )
                            ),
                            
                            h('div', { className: 'card' },
                                h('h3', { className: 'card-title', style: { marginBottom: '16px' } }, 
                                    'Select Models'),
                                
                                h('div', { className: 'checkbox-group' },
                                    [
                                        { type: 'linear', name: 'Linear Regression' },
                                        { type: 'logistic', name: 'Logistic Regression' },
                                        { type: 'tree', name: 'Decision Tree' },
                                        { type: 'bagging', name: 'Bagging' },
                                        { type: 'forest', name: 'Random Forest' },
                                        { type: 'adaboost', name: 'AdaBoost (Boosting)' },
                                        { type: 'svm', name: 'Support Vector Machine' },
                                        { type: 'nn', name: 'Neural Network' }
                                    ].map(m => {
                                        const checked = models.some(model => model.type === m.type);
                                        return h('label', { key: m.type, className: 'checkbox-label' },
                                            h('input', {
                                                type: 'checkbox',
                                                checked,
                                                onChange: e => {
                                                    if (e.target.checked) {
                                                        setModels([...models, m]);
                                                    } else {
                                                        setModels(models.filter(model => model.type !== m.type));
                                                    }
                                                }
                                            }),
                                            m.name
                                        );
                                    })
                                ),
                                
                                h('button', {
                                className: 'btn btn-secondary',
                                style: { marginTop: '12px' },
                                onClick: () => {
                                    data = [];
                                    setDataset([]);
                                    setFeatures([]);
                                    setTarget("");
                                    setSuccess("");
                                    setError("");
                                    alert('Upload cleared. You can safely upload a new file.');
                                }
                                }, 'Clear Upload')

                            )
                        ),
                        
                        currentView === 'train' && h('div', { className: 'card' },
                            h('h3', { className: 'card-title', style: { marginBottom: '24px' } }, 
                                'Training Configuration'),
                            
                            h('div', { style: { background: '#f9fafb', padding: '20px', borderRadius: '8px', marginBottom: '24px' } },
                                h('div', { style: { marginBottom: '12px' } },
                                    h('strong', null, 'Task: '),
                                    taskType
                                ),
                                h('div', { style: { marginBottom: '12px' } },
                                    h('strong', null, 'Dataset: '),
                                    `${(dataset?.length ?? 0)} rows`
                                ),
                                h('div', { style: { marginBottom: '12px' } },
                                    h('strong', null, 'Target: '),
                                    target
                                ),
                                h('div', { style: { marginBottom: '12px' } },
                                    h('strong', null, 'Features: '),
                                    features.join(', ')
                                ),
                                h('div', null,
                                    h('strong', null, 'Models: '),
                                    models.map(m => m.name).join(', ')
                                )
                            ),
                            
                            h('button', {
                                className: 'btn btn-success',
                                disabled: training,
                                onClick: handleTrain,
                                style: { 
                                    width: '100%',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    gap: '8px',
                                    padding: '14px'
                                }
                            },
                                training && h('span', { className: 'spinner' }),
                                training ? 'Training...' : 'âš¡ Start Training'
                            )
                        ),
                        
                        currentView === 'results' && (results.length === 0 ? 
                            h('div', { className: 'empty-state' },
                                h('div', { className: 'empty-icon' }, 'ðŸ“Š'),
                                h('div', { className: 'empty-title' }, 'No results yet'),
                                h('div', { className: 'empty-text' }, 'Train models to see results'),
                                h('button', {
                                    className: 'btn btn-primary',
                                    onClick: () => setCurrentView('train'),
                                    style: { marginTop: '16px' }
                                }, 'Start Training')
                            ) :
                            h('div', null,
                                h('div', { className: 'card' },
                                    h('h3', { className: 'card-title', style: { marginBottom: '20px' } }, 
                                        'Model Performance'),
                                    h('div', { className: 'table-container' },
                                        h('table', null,
                                            h('thead', null,
                                                h('tr', null,
                                                    h('th', null, 'Rank'),
                                                    h('th', null, 'Model'),
                                                    taskType === 'classification' ?
                                                        [h('th', { key: 'acc' }, 'Accuracy'),
                                                         h('th', { key: 'prec' }, 'Precision'),
                                                         h('th', { key: 'rec' }, 'Recall'),
                                                         h('th', { key: 'f1' }, 'F1')] :
                                                        [h('th', { key: 'mse' }, 'MSE'),
                                                         h('th', { key: 'mae' }, 'MAE'),
                                                         h('th', { key: 'rmse' }, 'RMSE'),
                                                         h('th', { key: 'r2' }, 'RÂ²')],
                                                    h('th', null, 'Time')
                                                )
                                            ),
                                            h('tbody', null,
                                                results
                                                    .sort((a, b) => taskType === 'classification' ?
                                                        (b.metrics.accuracy - a.metrics.accuracy) :
                                                        (a.metrics.mse - b.metrics.mse))
                                                    .map((r, i) =>
                                                        h('tr', { key: r.id },
                                                            h('td', null,
                                                                h('span', {
                                                                    className: `rank-badge rank-${Math.min(i + 1, 3)}`
                                                                }, i === 0 ? 'ðŸ†' : i + 1)
                                                            ),
                                                            h('td', null, h('strong', null, r.name)),
                                                            taskType === 'classification' ?
                                                                [h('td', { key: 'acc' }, (r.metrics.accuracy * 100).toFixed(1) + '%'),
                                                                 h('td', { key: 'prec' }, (r.metrics.precision * 100).toFixed(1) + '%'),
                                                                 h('td', { key: 'rec' }, (r.metrics.recall * 100).toFixed(1) + '%'),
                                                                 h('td', { key: 'f1' }, (r.metrics.f1 * 100).toFixed(1) + '%')] :
                                                                [h('td', { key: 'mse' }, r.metrics.mse.toFixed(4)),
                                                                 h('td', { key: 'mae' }, r.metrics.mae.toFixed(4)),
                                                                 h('td', { key: 'rmse' }, r.metrics.rmse.toFixed(4)),
                                                                 h('td', { key: 'r2' }, r.metrics.r2.toFixed(3))],
                                                            h('td', null, r.time + 'ms')
                                                        )
                                                    )
                                            )
                                        )
                                    )
                                ),
                                
                                h('div', { className: 'card' },
                                    h('h3', { className: 'card-title', style: { marginBottom: '20px' } }, 
                                        'Detailed Metrics'),
                                    h('div', { className: 'comparison-grid' },
                                        results
                                            .sort((a, b) => taskType === 'classification' ?
                                                (b.metrics.accuracy - a.metrics.accuracy) :
                                                (a.metrics.mse - b.metrics.mse))
                                            .map((r, i) =>
                                                h('div', { key: r.id, className: `comparison-card ${i === 0 ? 'best' : ''}` },
                                                    h('div', { className: 'comparison-card-header' },
                                                        h('div', { className: 'comparison-model-name' }, 
                                                            (i === 0 ? 'ðŸ† ' : '') + r.name),
                                                        i === 0 && h('span', { className: 'badge badge-success' }, 'Best')
                                                    ),
                                                    taskType === 'classification' ? [
                                                        h('div', { key: '1', className: 'metric-row' },
                                                            h('span', { className: 'metric-name' }, 'Accuracy'),
                                                            h('span', { className: 'metric-value' }, (r.metrics.accuracy * 100).toFixed(1) + '%')
                                                        ),
                                                        h('div', { key: '2', className: 'metric-row' },
                                                            h('span', { className: 'metric-name' }, 'Precision'),
                                                            h('span', { className: 'metric-value' }, (r.metrics.precision * 100).toFixed(1) + '%')
                                                        ),
                                                        h('div', { key: '3', className: 'metric-row' },
                                                            h('span', { className: 'metric-name' }, 'Recall'),
                                                            h('span', { className: 'metric-value' }, (r.metrics.recall * 100).toFixed(1) + '%')
                                                        ),
                                                        h('div', { key: '4', className: 'metric-row' },
                                                            h('span', { className: 'metric-name' }, 'F1 Score'),
                                                            h('span', { className: 'metric-value' }, (r.metrics.f1 * 100).toFixed(1) + '%')
                                                        ),
                                                        r.metrics.rocAuc && h('div', { key: '5', className: 'metric-row' },
                                                            h('span', { className: 'metric-name' }, 'ROC-AUC'),
                                                            h('span', { className: 'metric-value' }, r.metrics.rocAuc.toFixed(3))
                                                        )
                                                    ] : [
                                                        h('div', { key: '1', className: 'metric-row' },
                                                            h('span', { className: 'metric-name' }, 'MSE'),
                                                            h('span', { className: 'metric-value' }, r.metrics.mse.toFixed(4))
                                                        ),
                                                        h('div', { key: '2', className: 'metric-row' },
                                                            h('span', { className: 'metric-name' }, 'MAE'),
                                                            h('span', { className: 'metric-value' }, r.metrics.mae.toFixed(4))
                                                        ),
                                                        h('div', { key: '3', className: 'metric-row' },
                                                            h('span', { className: 'metric-name' }, 'RMSE'),
                                                            h('span', { className: 'metric-value' }, r.metrics.rmse.toFixed(4))
                                                        ),
                                                        h('div', { key: '4', className: 'metric-row' },
                                                            h('span', { className: 'metric-name' }, 'RÂ² Score'),
                                                            h('span', { className: 'metric-value' }, r.metrics.r2.toFixed(3))
                                                        )
                                                    ]
                                                )
                                            )
                                    )
                                ),
                                
                                taskType === 'classification' && results[0] && results[0].metrics.confusionMatrix &&
                                    h('div', { className: 'card' },
                                        h('h3', { className: 'card-title', style: { marginBottom: '20px' } }, 
                                            'Confusion Matrix (Best Model)'),
                                        h('div', { className: 'confusion-matrix' },
                                            h('div', { className: 'cm-cell cm-tn' },
                                                h('div', { className: 'cm-value' }, 
                                                    results.sort((a,b) => b.metrics.accuracy - a.metrics.accuracy)[0].metrics.confusionMatrix.tn),
                                                h('div', { className: 'cm-label' }, 'True Negative')
                                            ),
                                            h('div', { className: 'cm-cell cm-fp' },
                                                h('div', { className: 'cm-value' }, 
                                                    results.sort((a,b) => b.metrics.accuracy - a.metrics.accuracy)[0].metrics.confusionMatrix.fp),
                                                h('div', { className: 'cm-label' }, 'False Positive')
                                            ),
                                            h('div', { className: 'cm-cell cm-fn' },
                                                h('div', { className: 'cm-value' }, 
                                                    results.sort((a,b) => b.metrics.accuracy - a.metrics.accuracy)[0].metrics.confusionMatrix.fn),
                                                h('div', { className: 'cm-label' }, 'False Negative')
                                            ),
                                            h('div', { className: 'cm-cell cm-tp' },
                                                h('div', { className: 'cm-value' }, 
                                                    results.sort((a,b) => b.metrics.accuracy - a.metrics.accuracy)[0].metrics.confusionMatrix.tp),
                                                h('div', { className: 'cm-label' }, 'True Positive')
                                            )
                                        )
                                    ),
                                
                                taskType === 'classification' && results.find(r => r.metrics.rocCurve) &&
                                    h('div', { className: 'card' },
                                        h('h3', { className: 'card-title', style: { marginBottom: '20px' } }, 
                                            'ROC Curves'),
                                        h('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '20px', justifyContent: 'center' } },
                                            results.filter(r => r.metrics.rocCurve).map(r =>
                                                h('div', { key: r.id, style: { textAlign: 'center' } },
                                                    h('h4', { style: { marginBottom: '12px', fontSize: '14px' } },
                                                        `${r.name} (AUC: ${r.metrics.rocAuc.toFixed(3)})`),
                                                    h(ROCCurve, { points: r.metrics.rocCurve, auc: r.metrics.rocAuc })

                                                )
                                            )
                                        )
                                    )
                            )
                        )
                    )
                )
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(h(MLPlatform));
        console.log('âœ… ML Platform loaded');
    </script>
</body>
</html>
